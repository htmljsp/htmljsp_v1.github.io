---
layout: post
title:  "Ruby 中的线程 1"
date:   2018-09-28 12:00:00

categories: ruby
tags: thread
author: "Victor"
---

先说总结：进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。

## 进程、线程、多线程的基本概念

### 进程 process

* 狭义定义：进程就是一段程序的执行过程。
* 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。

进程的概念主要有两点：

1. 进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域 text region、数据区域 data region 和堆栈 stack region
  * 文本区域存储处理器执行的代码
  * 数据区域存储变量和进程执行期间使用的动态分配的内存
  * 堆栈区域存储着活动过程调用的指令和本地变量
2. 进程是一个执行中的程序

进程有三个状态：

1. 就绪：其实就是获取了出cpu外的所有资源，只要处理器分配资源就可以马上执行。
2. 运行：就是获得了处理器分配的资源，程序开始执行。
3. 阻塞：当程序条件不够时候，需要等待条件满足时候才能执行，如等待 i/o 操作时候，此刻的状态就叫阻塞态。

### 程序

* 程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。
* 进程则是在处理机上的一次执行过程，它是一个动态的概念。
* 进程是包含程序的，进程的执行离不开程序，进程中的文本区域就是代码区，也就是程序。

### 线程 Thread

一个进程中至少有一个线程，可以包含若干个线程。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。

### 多线程

在一个程序中，这些独立运行的程序片段叫作线程 Thread，利用它编程的概念就叫作多线程处理。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。

最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也不可能只有一节车厢。多线程的出现就是为了提高效率。

### 区别

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。

* 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。
* 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮。
* 进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

### 优缺点

* 线程执行开销小，但不利于资源的管理和保护，进程正相反
* 线程适合于在多核处理机 SMP 机器上运行，而进程则可以跨机器迁移

### 重点

一定要搞懂下面这一部分，后面的章节才能理解。

* 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。
* 但是每个线程拥有自己的栈段， 寄存器的内容，栈段又叫运行时段，用来存放所有局部变量和临时变量。
* 进程内的任何线程都被看做是同位体，且处于相同的级别。
  * 不管是哪个线程创建了哪一个线程，进程内的任何线程都可以销毁、挂起、恢复和更改其它线程的优先权。
  * 线程也要对进程施加控制，进程中任何线程都可以通过销毁主线程来销毁进程，销毁主线程将导致该进程的销毁，对主线程的修改可能影响所有的线程。

**子进程不对任何其他子进程施加控制，进程的线程可以对同一进程的其它线程施加控制。子进程不能对父进程施加控制，进程中所有线程都可以对主线程施加控制。**


## Puma

最初被设计为 Rubinius 的服务器，但是配合 JRuby 和 MRI 使用性能同样出色。Puma 使用真正的线程来利用 CPU 的所有核，因此不用再使用多进程来提高性能。

对于 MRI，因为全局锁（GIL）的限制，每次只能运行一个线程。但是对于大量阻塞IO的操作（例如调用Twitter API的HTTP请求），Puma 还是通过允许阻塞IO操作并行运行提高了 MRI 的性能。

### Ruby 的解释器和运行时

对于所有编程语言来说，语言规范与具体解释器及实现基本都是脱钩的。比如早期 W3C 标准和规范，可能标准都定义完了好几年，浏览器厂商才跟进规范。Ruby 也是一样，但由于缺乏正式的规范，我们所谓的 Ruby 新版本通常只与 Ruby MRI 的新版本相对应。

* MRI - Written in C by the Ruby core team lead by Yukihiro Matsumoto
* JRuby - 基于 JVM 的实现，意味着只要能运行 Java 的设备就能运行 Ruby，比如安卓
* Rubinius - 基于 LLVM 的实现，性能优于 MRI
* mruby - 可嵌入式版本
* Opal - 把 Ruby 编译成 JavaScript
* RubyMotion - 让 Ruby 可以访问 Cocoa APIs 也就能写 iOS 和 Mac 应用

### 配置

#### 线程池 threads

Puma 会基于流量自动调节线程数，范围从最小值到最大值。不要将最大线程数设置的过大，这样有可能会耗尽系统资源。

#### 集群模式 workers

支持使用 fork 出的进程配合已有的多线程功能来并发的处理请求。

* 在提供真正多线程的Ruby实现中，应该将 worker 数设置为可用的核数。
* 注意多线程仍然在集群模式下可用，使用 `-t` 来为每一个 worker 设置线程数，所以 `-w 2 -t 16:16` 就是 32 个线程。

在集群模式下  Puma 可以预加载应用。在 fork 之前加载整个项目代码。预加载通过利用操作系统的 copy-on-write 特性降低了内存的使用量。预加载不能和分步重启一起使用，因为分步重启需要一个个杀死 worker 再一个个重启，而 `preload_app` 是将 master 加载的代码拷贝到其他 workers。

```ruby
# config/puma.rb
workers 3
preload_app!
```

* 可以在配置文件中指定每个 worker 启动时需要执行的代码块
* 指定 fork 之前需要执行的代码块

```ruby
# config/puma.rb
on_worker_boot do
  # configuration here
  ActiveSupport.on_load(:active_record) do
    ActiveRecord::Base.establish_connection
  end
end

before_fork do
  # configuration here
  ActiveRecord::Base.connection_pool.disconnect!
end
```

## 相关链接

### 进程、线程

* [进程、线程、多线程相关总结](https://www.cnblogs.com/fuchongjundream/p/3829508.html)
* [进程和线程的区别、相同点](https://blog.csdn.net/qq_33573235/article/details/76588639)
* [进程与线程的一个简单解释](https://www.cnblogs.com/dreamroute/p/5207813.html)

### Puma

* [Puma: 为并发而生的Ruby Web服务器](https://www.jianshu.com/p/1bbc6ef924ce)
* [The Many Interpreters and Runtimes of the Ruby Programming Language](https://www.toptal.com/ruby/the-many-shades-of-the-ruby-programming-language)
* [Linux写时拷贝技术(copy-on-write)](https://www.cnblogs.com/lengender-12/p/7054896.html)
* [Copy-On-Write COW 技术简介](https://blog.csdn.net/u010039929/article/details/73321769)
